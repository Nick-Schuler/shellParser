%{
/*
 * lex input file
 *
 * Nick Schuler -- Sept 23, 2022
 */

#include <string.h>
#include <ctype.h>
#include "parser.tab.h"

/* some internal files generated by bison */
void yyerror(const char *s,...);
void yywarn(const char *s,...);
int yywrap(void) {return(1);}    // should be in library, but here it is for github

/* useful global variables */
extern int debug;

/* Everything up to the funny characters on the next line */
/* goes directly into the lex.yy.c file */
%}



/* The rest of this after the '%%' is lex rules */
%%

[ \t]+	        { }  /* Just ignore white space */

"\n" 	        { return(EOLN); } 

%{
/* this rule will get you "started" with the WORD token.  As you work on the project,
   you'll need to update it to support other characters too... */
%}
[\!\@\#\$\%\^\*\(\)\+\=\~\[\]\{\}\;\:\,\?\-\&'.0-9a-zA-Z_/]+ {
    /* a "WORD" */
    if (debug)
        printf("scanner saw WORD '%s'\n", yytext);
    yylval.string = strdup(yytext);  /* make a copy of the string */
    return(WORD);
}



%{
/* you need rules for the other reserved characters below */

/* you will also need a rule that returns "strings" as WORDS */
%}

\"{1} {yyerror("unterminated string");}
[|] {return(PIPE);}
[<] {return(INFILE);}
>{1} {return(OUTFILE);}
>{2} {return(OUTFILE_APPEND);}
2>{1} {return(ERRFILE);}
2>{2} {return(ERRFILE_APPEND);}

[\"][^\"\n]*[\"] {yytext = yytext + 1; /*return "string" as WORD with no " */
                 yytext[strlen(yytext) - 1] = '\0';
                 yylval.string = strdup(yytext);
                 return(WORD);
                 }



.		{
    /* if we haven't matched anything yet, then it's illegal */
    fprintf(stdout, "scanner: Bad character '%c'\n", *yytext);
}


%%
